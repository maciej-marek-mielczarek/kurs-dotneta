\documentclass[10pt]{article}

\usepackage[utf8]{inputenc} % linux
%\usepackage[cp1250]{inputenc} % windows
\usepackage[T1]{fontenc}
\usepackage{hyperref}
\usepackage{polski}
\usepackage[polish]{babel}

\setlength{\parskip}{1em}

\title{Notatki do 3. tygodnia kursu Dotneta}
\author{Maciek Mielczarek}

\begin{document}

\maketitle

\section{Wstęp. Stan aplikacji po 2. tygodniu}
U mnie jak i u przynajmniej kilkorga innych kursantów aplikacja ma przynajmniej 1 plik który ma kilkaset linii. Prawdopodobnie można to uznać za wyznacznik bałaganu, potrzeby refactoru i powtarzającego się kodu. Aplikacje jednak w jakimś stopniu działają.

\section{Konstruktory}
Stworzenie jakiegokolwiek konstruktora powoduje nie tworzenie konstruktora domyślnego.

Słowo this jest do wołania innych konstruktorów tej samej klasy. Wpisujemy je po dwukropku, jak wywołanie funkcji z parametrami, między listą parametrów a ciałem konstruktora. W tym miejscu możemy zamiast this użyć base, by wywołać konkretny konstruktor klasy bazowej.

Można zainicjalizować pola zaraz za wywołaniem konstruktora domyślnego, w nawiasach klamrowych.

\section{Przeciążanie metod}
W różnych wariantach metody o danej nazwie zwracamy ten sam typ.

Pojawiła się wzmianka o podpowiedziach IDE na temat przeciążonych metod. To całkiem przydatna funkcja, szczególnie gdy nie jesteśmy pewni jakich dokładnie danych potrzebuje dana funkcja, najczęściej napisana przez kogoś innego (np. twórców bibliotek standardowych).

\section{Dziedziczenie}
O dziedziczenie często pyta się na rozmowach rekrutacyjnych.

Przy dziedziczeniu klasa pochodna musi mieć konstruktory takie jak w klasie bazowej. Inne metody też mogą wołać metody klasy bazowej, w swoich ciałach poprzez base.Metoda().

W C\# każda klasa może dziedziczyć tylko po 1 klasie.

W programowaniu sieciowym często spotyka się klasę bazową AuditableModel z właściwościami mówiącymi kto i kiedy ją stworzył i zmodyfikował. Po tej klasie dziedziczy wszystko co chcemy zapisywać do bazy danych.

\section{Polimorfizm}

\end{document}
