\documentclass[10pt]{article}

\usepackage[utf8]{inputenc} % linux
%\usepackage[cp1250]{inputenc} % windows
\usepackage[T1]{fontenc}
\usepackage{hyperref}
\usepackage{polski}
\usepackage[polish]{babel}

\setlength{\parskip}{1em}

\title{Notatki do 4. tygodnia kursu Dotneta}
\author{Maciek Mielczarek}

\begin{document}

\maketitle

\tableofcontents

\section{Stan aplikacji}


\section{Projekt testowy}
Dla C\# mamy 3 popularne biblioteki do testowania aplikacji, będące bazami dla 3 typów projektów testowych:
\begin{itemize}
\item MSTest najstarszy, niemrawo rozwijany przez Microsoft,
\item NUnit, xunit tworzone przez społeczność dotnetową,
\item xUnit ma z tych 3 najprostszą składnię testów, więc to dobry wybór na początek.
\end{itemize}

Pojawiają się anotacje - słowa w nawiasach kwadratowych tuż nad metodami. Anotacja $"$Fact$"$ mówi, że zaznaczona metoda to metodą testową.

Wciśnięcie PPM na projekcie testowym w eksploratorze rozwiązania -> run tests, jak nazwa wskazuje, odpala testy.

Luźno latające okienka w IDE (przynajmniej niektóre), takie jak to z testami można, przez przeciągnięcie gdzieś do rogu, $"$zadokować$"$, czyli sprawić, żeby zostały w wyznaczonym miejscu i nie znikały po użyciu.

Zielone i czerwone kółka przy metodach testowych oznaczają wynik ostatniego testu i są skrótami do odpalania tego testu.

\section{Testy jednostkowe}
Test jednostkowy powinien zachowywać tak zwaną strukturę $"$AAA$"$, co jest skrótem od słów:
\begin{itemize}
\item Arrange (Przygotowanie). Tu przygotowujemy dane testowe.
\item Act (Działanie). Tu wykonujemy to, czego działanie chcemy przetestować.
\item Assert (Weryfikacja). Tu sprawdzamy poprawność tego, co stało się w poprzedniej części. Używamy do tego (metod) klasy Assert obecnej w praktycznie każdej bibliotece testowej.
\end{itemize}
Te części to po prostu kawałki kodu wykonywane po kolei i tworzące logiczne całości.

Testy jednostkowe są do sprawdzania czy najmniejsze części aplikacji (metody klas) działają poprawnie. Ten typ testów zawsze pisze programista. Testerzy są od testów obejmujących szerszy kontekst.

Istnienie testów oszczędza nam debugowania.

Metody nie powinny być zbyt duże, żeby łatwiej było się upewnić że działają poprawnie.

\end{document}
