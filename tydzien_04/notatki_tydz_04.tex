\documentclass[10pt]{article}

\usepackage[utf8]{inputenc} % linux
%\usepackage[cp1250]{inputenc} % windows
\usepackage[T1]{fontenc}
\usepackage{hyperref}
\usepackage{polski}
\usepackage[polish]{babel}

\setlength{\parskip}{1em}

\title{Notatki do 4. tygodnia kursu Dotneta}
\author{Maciek Mielczarek}

\begin{document}

\maketitle

\tableofcontents

\section{Stan aplikacji}


\section{Projekt testowy}
Dla C\# mamy 3 popularne biblioteki do testowania aplikacji, będące bazami dla 3 typów projektów testowych:
\begin{itemize}
\item MSTest najstarszy, niemrawo rozwijany przez Microsoft,
\item NUnit, xunit tworzone przez społeczność dotnetową,
\item xUnit ma z tych 3 najprostszą składnię testów, więc to dobry wybór na początek.
\end{itemize}

Pojawiają się anotacje - słowa w nawiasach kwadratowych tuż nad metodami. Anotacja $"$Fact$"$ mówi, że zaznaczona metoda to metodą testową.

Wciśnięcie PPM na projekcie testowym w eksploratorze rozwiązania -> run tests, jak nazwa wskazuje, odpala testy.

Luźno latające okienka w IDE (przynajmniej niektóre), takie jak to z testami można, przez przeciągnięcie gdzieś do rogu, $"$zadokować$"$, czyli sprawić, żeby zostały w wyznaczonym miejscu i nie znikały po użyciu.

Zielone i czerwone kółka przy metodach testowych oznaczają wynik ostatniego testu i są skrótami do odpalania tego testu.

\section{Testy jednostkowe}
Test jednostkowy powinien zachowywać tak zwaną strukturę $"$AAA$"$, co jest skrótem od słów:
\begin{itemize}
\item Arrange (Przygotowanie). Tu przygotowujemy dane testowe.
\item Act (Działanie). Tu wykonujemy to, czego działanie chcemy przetestować.
\item Assert (Weryfikacja). Tu sprawdzamy poprawność tego, co stało się w poprzedniej części. Używamy do tego (metod) klasy Assert obecnej w praktycznie każdej bibliotece testowej.
\end{itemize}
Te części to po prostu kawałki kodu wykonywane po kolei i tworzące logiczne całości.

Testy jednostkowe są do sprawdzania czy najmniejsze części aplikacji (metody klas) działają poprawnie. Ten typ testów zawsze pisze programista. Testerzy są od testów obejmujących szerszy kontekst.

Istnienie testów oszczędza nam debugowania.

Metody nie powinny być zbyt duże, żeby łatwiej było się upewnić że działają poprawnie. Te części które aktualnie nie są testowane, zakładamy że działają i symulujemy ich poprawne działanie przy użyciu biblioteki Moq.

\section{Biblioteka Moq}
Do testów nie używamy danych z bazy danych, tylko danych testowych.

Biblioteka Moq jest do tworzenia danych potrzebnych do testów i symulowania zachowania części aplikacji związanej z danymi. Te dane testowe i symulacje są po to, żeby trzymać bazę danych z daleka od testów jednostkowych, bo to nie ona jest tam testowana i nie wiadomo w jakim jest stanie. Stan bazy danych zapewne sprawdzany jest albo w ramach jakiegoś innego typu testów albo ręcznie.

Opcję zainstalowania biblioteki znajdziemy przez PPM na projekt testowy -> Manage NuGet Packages.

Obiekt klasy Mock<SymulowanaKlasa> (tym razem Mock, nie Moq) służy do symulowania działania klasy, która nie jest testowana w aktualnym teście, ale jest używana przez testowaną metodę. Jak zachowuje się obiekt $"$mock$"$ definiujemy np. poprzez mock.Setup(...).Returns(...). Jeśli chcemy użyć zasymulowanego obiektu zamiast prawdziwego, to zamiast nazwy zmiennej typu SymulowanaKlasa pisemy mock.Object.

\section{Biblioteka FluentAssertions}
Metody z tej biblioteki wołamy tak, jakbyśmy wołali metody sprawdzanego obiektu-odpowiedzi, a metody klasy Assert wołamy jako Assert.Metoda(...).

Kolejność Assertów ma znaczenie, bo funkcja testowa kończy się na pierwszym oblanym teście. Najpierw sprawdzamy bardziej ogólne warunki, np. jeśli wołamy metodę Dodaj(2,2), to najpierw sprawdzamy, czy wynik dodawania jest liczbą, a potem czy jest równy 4.

\section{Co testować?}
Jak coś nie zawiera logiki, np. konstruktor, standardowy getter czy setter albo proste operacje CRUD (które zwykle możemy znaleźć w Serwisie), to nie ma sensu tego testować. Natomiast np. klasy ze słowem Manager w nazwie zwykle mają metody które reagują na działania użytkownika i te metody na pewno chcemy testować.

Testy jednostkowe są do metod (funkcji). Nie testujemy testami jednostkowymi np. czy (klasa) Koń jest (czyli dziedziczy po klasie) Zwierzęciem i czy ma (pole typu lista, długości) 4 (zawierające obiekty typu) Nogi. Testujemy natomiast, np. czy metoda Koń.Idź(...) zwraca sensowne nowe położenie konia.

Nie testujemy też czy zewnętrzne biblioteki dobrze działają i generują sensowny kod. Tym zajmują się twórcy tych bibliotek. Polegamy tu na ich reputacji.

\end{document}
